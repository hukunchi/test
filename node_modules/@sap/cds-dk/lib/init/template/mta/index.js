const cds = require('@sap/cds')

const path = require('path')
const { nullLogger } = require('../../util/logger')
const TemplateBase = require('../templateBase');
const BuildTaskFactory = require('@sap/cds/lib/build/buildTaskFactory')
const { BUILD_TASK_HANA, BUILD_TASK_FIORI, BUILD_TASK_JAVA, BUILD_TASK_NODE, BUILD_TASK_MTX } = require("@sap/cds/lib/build/constants")

const TEMPLATE_PATH_MTA = path.join(__dirname, 'files/mta.yaml.hbs')

const P_LANGUAGE_JAVA = 'java'
const P_LANGUAGE_NODEJS = 'nodejs'
const DEFAULT_P_LANGUAGE = P_LANGUAGE_NODEJS

const { OPTION_MTA } = require('../../constants');

module.exports = class MtaTemplate extends TemplateBase {

    constructor(projectPath, generator) {
        super(projectPath, generator, __dirname);
    }

    getPriority() {
        return -Number.MAX_VALUE;
    }

    /**
     * Returns cds.env using 'productin' profile as mta build is also executed with having production profile set.
     */
    async getEnv() {
        const cdsEnvVar = process.env.CDS_ENV
        process.env.CDS_ENV = "production"
        let env
        try {
            env = await super.getEnv(true);
        } finally {
            cdsEnvVar ? process.env.CDS_ENV = cdsEnvVar : delete process.env.CDS_ENV
        }
        return env
    }

    async checkEnabled() {
        if (!this.options.add.has(OPTION_MTA)) {
            return false;
        }

        if (this.options.force) {
            return true;
        }

        if (await this.fsUtil.pathExists(path.join(this.projectPath, 'mta.yaml'))) {
            throw new Error(`File mta.yaml already exists in current folder. Use --force to overwrite.`);
        }

        return true;
    }

    async run() {
        super.run();

        const env = await this.getEnv();
        if (!this._hasHanaServiceBinding(env)) {
            this.logger.warn(`No hana service binding defined in the requires section of the project's package.json. Database module omitted in mta.yaml`) //NOSONAR
        }

        if (process.env.DEBUG) {
            this.logger.log(JSON.stringify(env, null, 1))
        }
        const context = await this.createContext()
        if (process.env.DEBUG) {
            this.logger.log(JSON.stringify(context, null, 1))
        }
        const mta = await this.processTemplate(context)
        await this.fsUtil.writeFile(path.join(this.projectPath, "mta.yaml"), mta)
    }

    async createContext() {
        const env = await this.getEnv();

        const appContext = {};
        const appDetails = await this._getAppDetails()
        const capContext = {
            appId: appDetails.appId,
            appName: appDetails.appName,
            appVersion: appDetails.appVersion,
            appDescription: appDetails.appDescription,
            pLanguage: DEFAULT_P_LANGUAGE,
            srvPath: null,
            appPath: null,
            db: [],
            requires: [],
            get isMultiTenant() {
                return this.requires.reduce((a, req) => {
                    return a || req.resource.isMultiTenant;
                }, false)
            },
            get isNodejs() {
                return this.pLanguage == 'nodejs'
            },
            get isJava() {
                return this.pLanguage == 'java'
            },
            get hasRequires() {
                return this.requires.length > 0
            },
            get hasRequiresDb() {
                return this.db.length > 0
            },
            get needsSidecar() {
                // {{#if (and (gt cap.db.length 0) (or (eq cap.pLanguage 'java') (ne cap.multiTenant true) ) ) }}
                return this.db.length > 0 && ( this.isJava || !this.isMultiTenant )
            },
        }

        cds.env = env;
        const buildTasks = await new BuildTaskFactory(process.env.DEBUG ? this.logger : nullLogger, cds).getTasks({ root: this.projectPath, resolve: true, mta: false })

        buildTasks.forEach((task) => {
            const relDestPath = MtaTemplate._slash(path.relative(this.projectPath, task.dest))

            switch (task.for) {
                case BUILD_TASK_HANA:
                    // check whether we have a hana service binding defined as a hana build task is returned by default for compatibility reasons if neither hana, nor sqlite has been defined
                    if (this._hasHanaServiceBinding(env)) {
                        capContext.db.push({ dbPath: relDestPath })
                    }
                    break

                case BUILD_TASK_JAVA:
                    capContext.pLanguage = P_LANGUAGE_JAVA
                    capContext.srvPath = relDestPath
                    break

                case BUILD_TASK_NODE:
                    capContext.srvPath = relDestPath
                    break

                case BUILD_TASK_FIORI:
                    capContext.appPath = MtaTemplate._slash(path.relative(this.projectPath, task.src).split(path.sep)[0])
                    break

                case BUILD_TASK_MTX:
                    break

                default:
                    throw new Error(`Unknown build task type ${task.for}`)
            }
        })

        this._addResourceDependencies(capContext, env)

        return { cap: capContext, app: appContext }
    }

    async processTemplate(context) {
        return this.templateUtil._processTemplateFile(TEMPLATE_PATH_MTA, context)
    }

    async _addResourceDependencies(capContext, env) {
        const hanaResources = new Map()
        const otherResources = new Map()

        for (let key of Object.keys(env.requires)) {
            if (env.requires[key].kind === 'hana') {
                hanaResources.set(key, env.requires[key])
            } else {
                otherResources.set(key, env.requires[key])
            }
        }
        for (let [key, value] of hanaResources) {
            let resource = this._getReqResource(key, value, capContext)
            if (resource) {
                // using production profile
                capContext.requires.push({ resource })
            }
        }
        // add after hana resource dependencies have been handled as multitenant information is required
        for (let [key, value] of otherResources) {
            let resource = this._getReqResource(key, value, capContext)
            if (resource) {
                // using production profile
                capContext.requires.push({ resource })
            }
        }
    }

    _hasHanaServiceBinding(env) {
        const kind = MtaTemplate._getProperty(env, 'requires.db.kind')
        return kind === 'hana' || (kind === 'sql' && MtaTemplate._getProperty(env, 'requires.db.use') === 'hana')
    }

    static _slash(filename) {
        return filename ? filename.replace(/\\/g, '/') : filename
    }

    _getReqResource(key, reqEntry, capContext) {
        const resource = {
            name: MtaTemplate._getResourceName(key, capContext),
            service: '',
            get isMultiTenant() {
                return reqEntry.multiTenant || false
            },
            vcap: reqEntry.vcap || {},
            get isManagedHana(){
                return this.service == 'managed-hana'
            },
            get isPlainHana(){
                return this.service == 'hana'
            },
            get isHana(){
                return this.isPlainHana || this.isManagedHana
            },
            get isXsuaa(){
                return this.service == 'xsuaa'
            },
        }

        switch (reqEntry.kind) {
            case 'sql':
            case 'hana':
                if (reqEntry.kind === 'sql' && reqEntry.use !== 'hana') {
                    break
                }
                // use different service name to avoid conflicts when switching from single tenant to multitenant
                // otherwise we would enforce that users have to delete the db container first
                if (resource.isMultiTenant) {
                    resource.name += '-mt'
                }
                resource.service = resource.isMultiTenant ? 'managed-hana' : 'hana'
                resource.vcap.plan = 'hdi-shared'
                break

            case 'xsuaa':
                if (capContext.isMultiTenant) {
                    resource.name += '-mt'
                }
                resource.service = reqEntry.kind
                resource.vcap.plan = 'application'
                break

            default: {
                if (MtaTemplate._getProperty(reqEntry, 'vcap.plan')) {
                    resource.service = reqEntry.kind
                } else if (process.env.DEBUG) {
                    this.logger.log(`Skip resource ${key}`)
                }
            }
        }
        return resource.service ? resource : null
    }

    static _getResourceName(key, capContext) {
        let name = key
        // only if not already present
        if (!name.includes(capContext.appName)) {
            name = capContext.appName + '-' + name
        }
        return name
    }

    async _getAppDetails() {
        const packageJson = await this.fsUtil.readJSON(path.join(this.projectPath, 'package.json'))

        let segments = packageJson.name ? packageJson.name.trim().split('/') : [path.basename(this.projectPath)]
        // scope as namespace
        if (segments[0].startsWith('@')) {
            segments[0] = segments[0].replace('@', '')
        }
        segments = segments.map(segment => segment.startsWith('@') ? encodeURIComponent(segment.replace('@', '')) : encodeURIComponent(segment))

        return {
            appName: segments[segments.length - 1],
            appId: segments.join('.'),
            appVersion: packageJson.version || '1.0.0',
            appDescription: packageJson.description || segments[segments.length - 1]
        }
    }

    static _getProperty(src, segments) {
        segments = Array.isArray(segments) ? segments : segments.split('.')
        return segments.reduce((p, n) => p && p[n], src)
    }

}
