const os = require('os');
const got = require('got');
const path = require('path');
const BaseCommand = require('./base_command');
const clientLog = require('./helper/logging');
const fs = require('fs-extra');
const fsHelper = require('./helper/fs_helper');

const COMMAND_URL_SUFFIX = 'asyncActivate';
const STATUS_URL_SUFFIX = 'status';
const UPDATE_CUSTOM_FILE_URL_SUFFIX = 'updateCustomTenantContent';

const I18N_WHITELIST = ['.properties', '.csv'];

const JOB_STATUS = {
    QUEUED: 'QUEUED',
    RUNNING: 'RUNNING',
    FINISHED: 'FINISHED',
    FAILED: 'FAILED'
};

async function checkFinished(jobId, statusUrl, authOptions, finisher) {
    const getOptions = Object.assign({
        method: 'GET'
    }, authOptions);
    let { body: jobResult } = await got(statusUrl, getOptions);

    if (!jobResult) {
        return finisher.reject(`Job ${jobId} failed: did not receive job result`);
    }
    if (typeof jobResult === 'string') {
        jobResult = JSON.parse(jobResult);
    }
    const { status, error } = jobResult;

    if (status === JOB_STATUS.FINISHED || status === JOB_STATUS.FAILED) {
        clearInterval(finisher.timer);
        if (status === JOB_STATUS.FAILED) {
            return finisher.reject(`Job ${jobId} failed: ${error}`);
        }
        clientLog.log('Extension active');
        finisher.resolve();
    }
}

class Apply extends BaseCommand {

    static get COMMAND_URL_SUFFIX() { return COMMAND_URL_SUFFIX; }
    static get UPDATE_CUSTOM_FILE_URL_SUFFIX() { return UPDATE_CUSTOM_FILE_URL_SUFFIX; }
    static get STATUS_URL_SUFFIX() { return STATUS_URL_SUFFIX; }

    static async run(sources, folder, { subdomain, to: url, passcode, username, password, undeploy, wsdl } = {}) {

        if (url && !url.endsWith('/')) {
            url = url + '/';
        }

        try {
            let projectFolder = Apply.getProjectFolder(folder);

            if (!await Apply.checkProject(projectFolder)) {
                throw new Error(projectFolder + ' is not a valid extension project');
            }

            const projectSettings = await Apply.getProjectSettings(projectFolder, url, subdomain, !username); // no subdomain change for activate
            try {
                clientLog.log(os.EOL + os.EOL + 'Activating extension');
                clientLog.log('Using url: ' + projectSettings.url);
                clientLog.log('From folder: ' + projectSettings.folder);
                clientLog.log('Undeploy: ' + !!undeploy);

                const authOptions = await Apply.determineAuthOptions(projectSettings, {
                    passcode,
                    username,
                    password
                });

                await Apply.runApply(sources, projectSettings.folder, authOptions, { to: projectSettings.url, undeploy });
                if (wsdl) {
                    await Apply.runCustomFileUpload(projectSettings.url, projectFolder, authOptions);
                }
            } catch (error) {
                await Apply.handleHttpError(error, projectSettings.folder, projectSettings.url);
            }
        } catch (mainError) {
            clientLog.error(mainError, mainError.message);
        }
    }

    static async collectExtensionFiles(compile, cds, projectFolder) {

        const absoluteFolder = projectFolder;
        const dbFolder = path.join(absoluteFolder, 'db');
        const srvFolder = path.join(absoluteFolder, 'srv');

        const resolvedPathDb = cds.resolve(dbFolder, { root: dbFolder });
        const resolvedPathSrv = cds.resolve(srvFolder, { root: srvFolder });

        let resolvedPaths = [];
        if (resolvedPathSrv) {
            resolvedPaths = resolvedPaths.concat(resolvedPathSrv);
        }

        if (resolvedPathDb) {
            resolvedPaths = resolvedPaths.concat(resolvedPathDb);
        }

        let allFiles = new Map();

        if (resolvedPaths.length < 1) {
            clientLog.log('No extension files found');
            return allFiles;
        }

        const csn = await compile(resolvedPaths, projectFolder);

        const filteredSources = csn._sources.filter((entry) => {
            const unixFilename = fsHelper.fixFileName(entry);
            if (!/.*node_modules\/_base\/.*/.test(unixFilename)) {
                return true;
            } else {
                return false;
            }
        });

        let sourceFiles = await fsHelper.collectFileContent(filteredSources, projectFolder);
        allFiles = new Map([...allFiles, ...sourceFiles]);

        const modelFiles4I18n = {
            _sources: filteredSources
        }

        let i18nFolders = cds.localize.folders4(modelFiles4I18n);
        i18nFolders = i18nFolders.filter(i18nFolder => {
            const unixFilename = fsHelper.fixFileName(i18nFolder);
            return !(/.*node_modules\/_base\/.*/.test(unixFilename));
        });

        i18nFolders.forEach(async(folder) => {
            let i18nFiles = await fsHelper.collectFiles(projectFolder, folder, (entry) => {
                const ext = path.extname(entry);
                return I18N_WHITELIST.includes(ext);
            });
            allFiles = new Map([...allFiles, ...i18nFiles]);
        });

        try {
            const pkgJson = await fs.readFile(path.join(absoluteFolder, 'package.json'), 'utf-8');
            allFiles.set('package.json', pkgJson);
        } catch(e) {
            clientLog.log('No package.json file found');
            clientLog.error(e, 'No package.json file found');
        }

        return allFiles;
    }

    static async collectCustomFiles(projectFolder) {
        const wsdlFolder = path.join(projectFolder, 'wsdl');

        try {
            const wsdlFiles = await fsHelper.collectFiles(projectFolder, wsdlFolder);
            if (wsdlFiles.length === 0) {
                clientLog.log('No custom files found');
            }
            return wsdlFiles;
        } catch (error) {
            clientLog.error(error, error.message);
            throw new Error('No custom files found');
        }
    }

    static async runApply({ compile, cds }, projectFolder, authOptions, { to: url, undeploy }) {
        return new Promise(async (resolve, reject) => {
            const allFiles = await Apply.collectExtensionFiles(compile, cds, projectFolder);
            if (allFiles.size === 0) {
                return resolve();
            }

            clientLog.log('Activating extension...');

            const activationUrl = Apply.getMtxApiUrl(url, Apply.COMMAND_URL_SUFFIX);
            const options = Object.assign({
                method: 'POST',
                body: {
                    extension: [...allFiles],
                    undeployExtension: undeploy
                },
                json: true
            }, authOptions);

            try {
                var { body: { jobID: jobId, statusPath } } = await got(activationUrl, options);
            } catch (error) {
                let errorMessage = error;
                if (error.statusCode === 422) {
                    errorMessage = error.body.error.message;
                }
                return reject(errorMessage);
            }

            if (jobId === undefined) {
                return reject('Activation failed: did not receive job ID');
            }

            if (!statusPath) {
                return reject(`Job ${jobId} failed: did not receive job-status path`);
            }

            clientLog.debug(null, `Job ID: ${jobId}`);

            const statusUrl = new URL(statusPath, activationUrl).toString();
            const finishers = {
                resolve,
                reject
            };
            finishers.timer = setInterval(checkFinished.bind(undefined, jobId, statusUrl, authOptions, finishers), 250);
        });
    }

    static async runCustomFileUpload(url, projectFolder, authOptions) {
        clientLog.log(`Uploading custom files to ${url}...`);

        const customFiles = await Apply.collectCustomFiles(projectFolder);

        const customFilesSerialized = [];
        customFiles.forEach((value, key) => {
            customFilesSerialized.push({
                category: "wsdl",
                name: key,
                content: value
            });
        });

        const customFileUrl = Apply.getMtxApiUrl(url, Apply.UPDATE_CUSTOM_FILE_URL_SUFFIX);
        const options = Object.assign({
            method: 'POST',
            body: {
                content: customFilesSerialized
            },
            json: true
        }, authOptions);

        try {
            await got(customFileUrl, options);
        } catch (error) {
            let errorMessage = error;
            if (error.statusCode === 422) {
                errorMessage = error.body.error.message;
                throw new Error(errorMessage);
            }
            throw error;
        }

        clientLog.log('Custom file upload finished');
    }

}

module.exports = Apply;
