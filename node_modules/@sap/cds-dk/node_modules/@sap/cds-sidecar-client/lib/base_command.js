const MTX_URL_PATH_PREFIX = 'mtx/v1/model/';
const CUSTOM_FILE_URL_SUFFIX = 'customTenantContent';

const path = require('path');
const fs = require('fs-extra');
const { URL } = require('url');
const clientLog = require('./helper/logging');
const jwtRequestHelper = require('./helper/jwt_request_helper');
const ProjectSettings = require('./helper/project_settings');
const urlHelper = require('./helper/url_helper');

class BaseCommand {

    static get CUSTOM_FILE_URL_SUFFIX() { return CUSTOM_FILE_URL_SUFFIX; }

    static async checkProject(folder) {
        return fs.pathExists(path.join(folder, 'package.json'));
    }

    static async getToken(url, options) {
        return jwtRequestHelper.getToken(url, options);
    }

    static getProjectFolder(projectFolder, subdomain) {
        if (!projectFolder) {
            if (subdomain) {
                projectFolder = subdomain;
                clientLog.log('No directory specified. Using subdomain name as directory.')
            } else {
                projectFolder = '.';
            }
        }

        return path.resolve(projectFolder);
    }

    static getSubdomain(subdomain, appUrl) {
        if (!subdomain) {
            if (appUrl) {
                return urlHelper.getSubdomain(appUrl);
            } else {
                throw new Error('Subdomain could not be determined. Please provide subdomain or url parameter');
            }
        } else {
            return subdomain;
        }
    }

    static async storeSettings(projectFolder, projectData) {
        try {
            const ps = new ProjectSettings();
            await ps.addSettings(projectFolder, projectData);
        } catch (error) {
            clientLog.error(error, 'Could not store settings');
        }
    }

    static async loadSettings(projectFolder) {
        clientLog.debug(null, `Loading settings for project ${projectFolder}`);

        try {
            const ps = new ProjectSettings();
            return await ps.loadSettings(projectFolder);
        } catch (error) {
            clientLog.error(error, 'Could not read settings');
        }
    }

    static async deleteSettings(projectFolder) {
        try {
            const ps = new ProjectSettings();
            await ps.removeSettings(projectFolder);
        } catch (error) {
            clientLog.error(error, 'Could not access project settings');
        }
    }

    static async deleteAllSettings() {
        try {
            const ps = new ProjectSettings();
            await ps.removeAllSettings();
        } catch (error) {
            clientLog.error(error, 'Could not access project settings');
        }
    }


    static async handleHttpError(error, projectFolder, appUrl) {
        projectFolder = path.resolve(projectFolder);
        if (error.name === 'HTTPError') {
            if (error.statusCode === 401) {
                if (error.body && error.body.error && error.body.passcode_url) {
                    const authError = error.body;
                    clientLog.error(error, `${authError.error_description}: Get valid passcode from url ${authError.passcode_url} and rerun the command using -p <passcode>`);
                } else {
                    let storedSettings = await BaseCommand.loadSettings(projectFolder);
                    if (storedSettings && storedSettings.passcode_url) {
                        clientLog.error(error, `Request failed. Authorization might have expired: Get valid passcode from url ${storedSettings.passcode_url}`);
                    } else if (error.body.error_description) {
                        clientLog.error(error, error.body.error_description);
                    }
                }
                return;
            } else if (error.statusCode === 404) {
                clientLog.error(error, `Request failed. Please check application url ${appUrl}`);
                return;
            }
        }
        clientLog.error(error, error.message);
    }

    static getMtxApiUrl(url, action) {
        const parsedUrl = new URL(url);

        parsedUrl.pathname = path.join(parsedUrl.pathname, MTX_URL_PATH_PREFIX, action);

        return parsedUrl.toString();
    }

    static async getProjectSettings(folder, appUrl, subdomain, loadStoredSettings) {

        let resolvedProjectFolder = path.resolve(folder);

        let storedProjectSettings = loadStoredSettings ? await BaseCommand.loadSettings(resolvedProjectFolder) : null;

        if (storedProjectSettings) {
            if (subdomain && (subdomain !== storedProjectSettings.subdomain)) {
                throw new Error(`Subdomain ${storedProjectSettings.subdomain} stored for project differs from given subdomain ${subdomain}`);
            }
            return Object.assign(storedProjectSettings, { folder: resolvedProjectFolder });
        } else {
            clientLog.log('No stored project settings found.');

            let usedSubdomain = BaseCommand.getSubdomain(subdomain, appUrl);

            return { folder: resolvedProjectFolder, url: appUrl, subdomain: usedSubdomain };
        }
    }

    static async determineAuthOptions(projectSettings, { passcode, username, password }) {
        let authOptions = {
            headers: {}
        };

        if (!username) {

            let token = projectSettings.token;

            if (!token || passcode) {
                clientLog.debug(null, `No authorization token found, trying to get one using passcode`);
                const tokenResponse = await BaseCommand.getToken(projectSettings.url, { subdomain: projectSettings.subdomain, passcode });
                token = tokenResponse.body.access_token;
                let passcode_url = tokenResponse.body.passcode_url;
                if (token) {
                    await BaseCommand.storeSettings(projectSettings.folder, { url: projectSettings.url, token, passcode_url, subdomain: projectSettings.subdomain });
                } else {
                    if (!passcode) {
                        throw new Error(`No passcode provided: Get valid passcode from url ${passcode_url} and rerun the command using -p <passcode>`);
                    } else {
                        throw new Error('Getting authorization token failed');
                    }
                }
            }
            authOptions.headers.Authorization = 'Bearer ' + token;
        } else {
            authOptions.auth = username + ':' + password;
        }
        return authOptions;
    }

}

module.exports = BaseCommand;
